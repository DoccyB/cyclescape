jQuery ->
  class LeafletMap
    @OpenCycle: 'https://tile.cyclestreets.net/opencyclemap/{z}/{x}/{y}@2x.png'
    @OSStreet: 'https://tile.cyclestreets.net/osopendata/{z}/{x}/{y}.png'
    @Mapnik: 'https://tile.cyclestreets.net/mapnik/{z}/{x}/{y}.png'
    @CyclestreetsKey: "<%= Geocoder::API_KEY %>"
    @CyclestreetsGeoUrl: "<%= Geocoder::URL %>"
    @CyclestreetsCollisionUrl: "<%= Geocoder::COLLISIONS_URL %>"

    constructor: (center, opts) ->
      @domId = opts.domid || 'map'
      @map = L.map(@domId, maxZoom: 18)
      @setCenter(center)
      @geoInput = $("##{opts.geoinput}_loc_json")
      @buildCollistionLayer() if opts.collisions?
      @remoteJSONLayer = {}
      @buildRemoteLayer(url, name) for own name, url of opts.remote
      @addLayers(opts.hidelayers)
      @addSearch() if opts.search?
      if opts.draw?
        @addDraw(opts.feature)
      else if opts.feature?
        @addStaticFeature(opts.feature)
      @map.removeControl(@map.zoomControl) if opts.hidezoom?

    featurePointToLayer: (feature, latlng) =>
      icon = new L.Icon(iconUrl: feature.properties.thumbnail, iconAnchor: feature.properties.anchor)
      L.marker(latlng, {icon: icon}).addTo @map

    addStaticFeature: (collection) ->
      L.geoJson(collection, {
        style: {color: 'black'}, pointToLayer: @featurePointToLayer
      }).addTo @map
      return

    buildRemoteLayer: (url, name) ->
      remoteLayer = L.geoJson(null, {
        pointToLayer: @featurePointToLayer.bind(@)
        fillOpacity: 0.1
        stroke: 'black'
        onEachFeature: (feature, layer) ->
          img = if feature.properties.image_url
            "<img src='#{feature.properties.image_url}' width='37' height='37'>"
          else
            ''
          layer.bindPopup( "#{img}
           <h3><a href='#{feature.properties.url}'> #{feature.properties.title} </a></h3>
           <p>created by <a href='#{feature.properties.created_by_url}'> #{feature.properties.created_by} </p>"
          )
      }).addTo(@map)
      @remoteJSONLayer[name] = new L.LayerJSON({
        url: "#{url}?bbox={lon1},{lat1},{lon2},{lat2}"
        propertyItems: 'features'
        propertyLoc: 'geometry.coordinates'
        updateOutBounds: false
        hashGenerator: (data) ->
          data.id
        dataToMarker: remoteLayer.addData.bind(remoteLayer)
      }).addTo(@map)

    setCenter: (center) ->
      @map.fitBounds(center.fitBounds) if center.fitBounds?
      @map.setView(center.latLon, center.zoom) if center.latLon
      return

    addLayers: (hidelayers) ->
      openCycle = L.tileLayer(@constructor.OpenCycle, opacity: 0.8)
      openCycle.addTo(@map)
      baseLayers = {
        "OpenCycleMap":  openCycle,
        "OS StreetView": L.tileLayer(@constructor.OSStreet, opacity: 0.8),
        "OpenStreetMap": L.tileLayer(@constructor.Mapnik, opacity: 0.8),
      }
      additionalLayers = @remoteJSONLayer
      additionalLayers['Collisions'] = @collisionLayer if @collisionLayer

      L.control.layers(baseLayers, additionalLayers).addTo(@map) unless hidelayers

    search: (text, callback) =>
      bbox = @map.getBounds().toBBoxString()
      params = [
        {name: 'q', value: text}
        {name: 'key', value: @constructor.CyclestreetsKey}
        {name: 'bbox', value: bbox},
        {name: 'geometries', value: 1}
      ]
      $.ajax(
        url: @constructor.CyclestreetsGeoUrl
        data: params
        dataType: 'jsonp'
        timeout: 10000
        success: callback
      )

    buildCollistionLayer: =>
      lookup = {
        fatal: { color: '#aa0000', fillColor: '#ff0000', radius: 10 },
        serious: { color: '#e44500', fillColor: '#ff8814', radius: 8 },
        slight: { color: '#a7932f', fillColor: '#fcff00', radius: 6 }
      }
      params = [
        {name: 'key', value: @constructor.CyclestreetsKey}
        {name: 'fields', value: 'id,latitude,longitude,datetime,severity,url'},
        {name: 'datetime', value: 'friendly'},
      ]
      @collisionLayer = new L.LayerJSON({
        url: "#{@constructor.CyclestreetsCollisionUrl}?#{$.param(params)}&bbox={lon1},{lat1},{lon2},{lat2}"
        propertyItems: 'features'
        propertyLoc: ['properties.latitude','properties.longitude'],
        dataToMarker: (feature, latlng) =>
          props = lookup[feature.properties.severity]
          marker = new L.CircleMarker(latlng, props).addTo @collisionLayer
          marker.bindPopup(
            "<h3><a href=\"#{feature.properties.url}\">Collision #{feature.properties.id}</a></h3>
            <p>Date and time: #{feature.properties.datetime} </p>
            <p>Severity: #{feature.properties.severity} </p>
            <p><a href=\"#{feature.properties.url}\">View on CycleStreets</a></p>"
          )
      })

    formatJSON: (rawjson) ->
      json = {}
      featureName = (props) ->
        "#{props.name} (#{props.near})"

      # Hacked Leaflet.search for it to work with features but potential solution is here:
      # https://github.com/stefanocudini/leaflet-search/pull/111#issuecomment-210533909
      for feature in rawjson.features
        json[featureName(feature.properties)] = L.geoJson(type: "FeatureCollection", features: [feature])
      json

    addSearch: =>
      @map.addControl(
        new (L.Control.Search)(
          autoCollapse: true
          sourceData: @search
          formatData: @formatJSON
          markerLocation: false
          autoType: false
          minLength: 2)
      )

    addDraw: (feature) =>
      hideNewToolbars = ->
        $('.tabs').children('li.area, li.route, li.point').css({opacity: 0.3}).prop('disabled', true)
      showNewToolbars = ->
        $('.tabs').children('li.area, li.route, li.point').css({opacity: 1}).prop('disabled', false)

      drawnItems = new L.FeatureGroup()
      @map.addLayer drawnItems
      drawControl = new L.Control.Draw {
        position: 'topright'
        edit: {
          featureGroup: drawnItems
        }
        draw: {
          circle: false
          rectangle: false
        }
      }

      @map.addControl drawControl
      @map.on 'draw:created', (e) =>
        layer = e.layer
        drawnItems.addLayer layer
        @geoInput.val JSON.stringify(layer.toGeoJSON())
        hideNewToolbars()

      if feature
        drawnItems.addLayer L.geoJson(feature)
        hideNewToolbars()

      # enable area / polygon draw as standard
      $(".leaflet-draw-draw-polygon")[0].click()

      # Bind our icons to the Leaflet draw icons
      lDrawMapping = {
        area: "draw-polygon"
        route: "draw-polyline"
        point: "draw-marker"
      }

      for own localN,lDrawName of lDrawMapping
        $("li.#{localN} a").click (evt) ->
          target = evt.target
          if $(target).parent().parent().prop('disabled')
            false
          else
            $(".leaflet-draw-#{lDrawMapping[target.className]}")[0].click()

      # When drawing clear cancels the drawing
      # Otherwise clear wipes any shapes on the map
      $('.edit-clear').click ->
        drawnItems.clearLayers()
        $('ul.leaflet-draw-actions a[title^="Cancel"]')[0]?.click()
        $('.tabs').children('li.area, li.route, li.point').css({opacity: 1}).prop('disabled', false)
        @geoInput?.val(null)

      # When drawing undo deletes the last point
      # Otherwise undo edits the layer
      undoSelector = '.leaflet-draw-edit-edit'
      @map.on 'draw:drawstart', (e) ->
        undoSelector = 'ul.leaflet-draw-actions a[title^="Delete"]'

      @map.on 'draw:drawstop', (e) ->
        undoSelector = '.leaflet-draw-edit-edit'

      $('.edit-undo').click ->
        $(undoSelector)[0].click()

  for domMap in $('.map-data')
    new LeafletMap($(domMap).data('center'), $(domMap).data('opts'))
