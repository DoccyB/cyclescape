%form.formtastic.user_location
  %fieldset.inputs
    %ol
      %li.string.input.optional.stringish
        .left{style: "float: left"}
          %label.label{for: "user_location", style: "width: auto"}
            My location
          %a#auto_detect.btn-grey.hide{href: "#", title: "Create a location based on where you are now"} Use current location
        .leaflet-search-outside#user_location
        .leaflet-search-outside#dest_location
      %li
        %label.location-presets
          = check_box_tag :area_around_me, '', false, disabled: true
          Area around me
        %label.location-presets
          = check_box_tag :constituency, '', false, disabled: true
          My ward / constituency
        %label.location-presets
          = check_box_tag :route, '', false, disabled: true
          Route (to destination)

= semantic_form_for @location do |f|
  = f.inputs do
    = f.input :loc_json, as: :hidden
    %li.input
      = f.semantic_errors :location
      = render partial: "shared/edit_map", locals: {resource: @location, location: @start_location, skip: true, no_search: true}
    = f.input :category
  = f.actions do
    = f.action :submit, button_html: {class: "btn-big-green"}

:javascript
  $(document).ready(function() {
    var map, startSearchControl, destSearchControl, startSearchEl, destSearchEl, startLocation, destLocation;
    map = new LeafletMap($(".map-data").data('center'), $(".map-data").data('opts'));
    startSearchControl = map.addSearchControl(
      {autoCollapse: false, collapsed: false, circleLocation: false, startLocation: true, textPlaceholder: "Start/home location"}
    );
    destSearchControl = map.addSearchControl(
      {autoCollapse: false, collapsed: false, circleLocation: false, destLocation: true, textPlaceholder: "Regular destination (optional)"}
    );
    startSearchEl = startSearchControl.getContainer();
    destSearchEl = destSearchControl.getContainer();
    $("#user_location").append(startSearchEl);
    $("#dest_location").append(destSearchEl);

    startSearchControl.on("search_locationfound", function(e) {
      $("#constituency").prop("disabled", false);
      $("#area_around_me").prop("disabled", false);
      if (destLocation) {
        $("#route").prop("disabled", false);
      }
      startLocation = [e.latlng.lat, e.latlng.lng];
    });

    destSearchControl.on("search_locationfound", function(e) {
      if (startLocation) {
        $("#route").prop("disabled", false);
      }
      destLocation = [e.latlng.lat, e.latlng.lng];
    });

    $("#area_around_me").change(function(e) {
      if(e.target.checked) {
        map.drawCircle(startLocation);
      } else {
        map.drawCircle();
      }
    })

    $("#constituency").change(function(e) {
      if(e.target.checked) {
        $.ajax({
          url: "/api/constituencies",
          data: { geo: L.marker(startLocation).toGeoJSON().geometry },
          dataType: jsonpTransportRequired() ? 'jsonp' : void 0,
          timeout: 10000,
          success: function(constituencyGeo) {
            map.drawFeatureId(constituencyGeo, "constituency");
          }
        });
      } else {
        map.drawFeatureId(null, "constituency");
      }
    })

    $("#route").change(function(e) {
      if(e.target.checked) {
        var params = [
          { name: "key", value: "#{Geocoder::API_KEY}" },
          { name: "itinerarypoints", value: startLocation[1] + "," + startLocation[0] + "|" + destLocation[1] + "," + destLocation[0] },
          { name: "plan", value: "balanced"}
        ];
        $.ajax({
          url: "http://www.cyclestreets.net/api/journey.json?" + $.param(params),
          dataType: jsonpTransportRequired() ? 'jsonp' : void 0,
          timeout: 10000,
          success: function(json) {
            var route = L.polyline([]), markers = json.marker, points, m, mLen, p, pLen, startPoint;

            for (m = 0, mLen = json.marker.length; m < mLen; m++) {
              var points = markers[m]["@attributes"].points;
              if (points) {
                points = markers[m]["@attributes"].points.split(" ");
                if(m == 1) {
                  startPoint = 0;
                } else {
                  startPoint = 1;
                }
                for (p = startPoint, pLen = points.length; p < pLen; p++) {
                  route.addLatLng(points[p].split(",").reverse());
                };
              }
            }
            map.drawFeatureId(route.toGeoJSON(), "route");
          }
        });
      } else {
        map.drawFeatureId(null, "route");
      }
    })

    if (navigator.geolocation) {
      var updateLocation = function(position){
        map.drawCircle(position.coords);
      }
      $("#auto_detect").css('display','inline-block').click(function() {
        navigator.geolocation.getCurrentPosition(updateLocation);
      });
    }
  });
